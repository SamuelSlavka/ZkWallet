import "hashes/sha256/1024bit.zok" as sha256for1024
import "hashes/sha256/256bitPadded.zok" as sha256for256

import "utils/pack/bool/pack256.zok" as boolPack256
import "utils/pack/u32/pack256.zok" as u32Pack256
import "utils/pack/u32/unpack128.zok" as unpack128

import "utils/casts/u32_from_bits.zok" as u32_from_bits
import "utils/casts/u32_to_bits.zok" as u32_to_bits
import "utils/casts/u64_to_bits.zok" as u64_to_bits

// gets target exponent as input and checks if blocks head has number of zeros in binary target
// as the header bits tail side only shifts head side by 2^(8*head-3)
def check_exponent(bool[224] input, u32 expected) -> u32[2]:
    u32 count = 0
    u32 stop = 1
    for u32 i in 0..223 do
        stop = (input[223-i] == false) ? stop : 0 
        count = count + stop
    endfor
    expected = 8*(expected - 3)
    return [count,expected]

// checks if target exponent has on the left side the tail from header
def check_multiplier(bool[224] input, u32 expected, u32 exponent) -> u32[2]:
    bool[32] res = [false; 32]
    for u32 i in 0..223 do
        res[i%32] = (i > (224-exponent)) ? res[i%32] : input[i]
    endfor
    u32 mul = u32_from_bits(res)
    mul = mul >> 16
    return [mul,expected]

// target calculation is based on the folloing equation: tail * 2^(8*(head - 3))
// retreives target from header and checks if input target was created by it
def check_target(u32 bits, u64[4] expectedTarget) -> field:
    bool[224] boolExpectedTarget = [...u64_to_bits(expectedTarget[0])[32..64], ...u64_to_bits(expectedTarget[1]), ...u64_to_bits(expectedTarget[2]), ...u64_to_bits(expectedTarget[3])]
    bool[32] boolBits = u32_to_bits(bits)

    bool[32] head = [...[false;24],...boolBits[24..32]]
    bool[32] tail = [...[false;8],...boolBits[16..24],...boolBits[8..16],...boolBits[0..8]]
    u32 inthead = u32_from_bits(head)
    u32 inttail = u32_from_bits(tail)

    u32[2] exp = check_exponent(boolExpectedTarget, inthead)
    assert(exp[0] == exp[1])
    u32[2] mul = check_multiplier(boolExpectedTarget, inttail, exp[1])
    assert(mul[0] == mul[1])
    // return target if is valid
    return boolPack256([...[false;32], ...boolExpectedTarget])

// changes endianess in u32
def change_val_endianness(u32 input) -> u32:
    bool[32] boolInput = u32_to_bits(input)
    bool[32] boolTruncated = [...boolInput[24..32],...boolInput[16..24],...boolInput[8..16],...boolInput[0..8]]
    return u32_from_bits(boolTruncated)

// changes endianess in u32 array
def change_array_endainnes(u32[8] input) -> u32[8]:
    u32[8] changed = input
    for u32 i in 0..8 do
        changed[7-i] = change_val_endianness(input[i])
    endfor
    return changed

// make two sha256 on header
def hash_block_header(u32[5][4] preimage) -> field:    
    // combined into 256b fields and add padding
    u32[8] preimage1 = [ ...preimage[0], ...preimage[1] ]
    u32[8] preimage2 = [ ...preimage[2], ...preimage[3] ]
    u32[8] preimage3 = [ ...preimage[4], 0x80000000,0x00000000,0x00000000,0x00000000 ]

    u32[8] dummy = [ 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000280 ]
    
    u32[8] intermediary = sha256for1024(preimage1, preimage2, preimage3, dummy)
    u32[8] res = sha256for256(intermediary)
    res = change_array_endainnes(res)
	return u32Pack256(res)

// return previous block hash from header
def get_prev_hash(u32[8] hash) -> field:
    u32[8] res = change_array_endainnes(hash)
    return u32Pack256(res)

// takes in epoch and vaildates it
def main(field[16][5] fieldHeader, u64[16][4] expectedTarget, field[16] currentHash, field previousHash) -> bool:
    
    for u32 i in 0..2 do
        u32[4] header0 = unpack128(fieldHeader[i][0])
        u32[4] header1 = unpack128(fieldHeader[i][1])
        u32[4] header2 = unpack128(fieldHeader[i][2])
        u32[4] header3 = unpack128(fieldHeader[i][3])
        u32[4] header4 = unpack128(fieldHeader[i][4])

        field currentHashFromHeader = hash_block_header([header0,header1,header2,header3,header4])
        field target = check_target(header4[2], expectedTarget[i])
        field previousHashFromHeader = get_prev_hash( [...header0[1..4],...header1[0..4],header2[0]])
        // hash needs to be under target
        assert(target > currentHashFromHeader)
        // hash needs to equal hash calculated in server
        assert(currentHash[i] == currentHashFromHeader)
        // previous hash field in header needs to equal previous hash
        assert(previousHash == previousHashFromHeader)
        // set previous hash to current hash
        previousHash = currentHashFromHeader
    endfor
    return true
